# Technical Design: Prompt Fusion Swap

## 1. Project Overview

**Prompt Fusion Swap** is a next-generation DeFi terminal that merges a real-time, analytical portfolio dashboard with an AI-powered, natural language command interface. It allows users to instantly grasp their asset allocation and execute complex trades as easily as talking to an assistant, all powered by 1inch APIs.

## 2. Technical Stack

| Category | Technology | Purpose |
| :--- | :--- | :--- |
| **Framework** | Next.js 14+ (App Router) | Full-stack development (Frontend, API Proxy) |
| **Language** | TypeScript | Type safety and developer efficiency |
| **UI Library** | shadcn/ui, Tailwind CSS | Rapidly build modern, maintainable UI |
| **State Management** | Zustand | Simple and lightweight global state management |
| **Wallet Integration** | wagmi & Viem | Robust connection and interaction with EVM wallets |
| **LLM API** | Gemini API | Natural language intent parsing via Function Calling |
| **Deployment** | Vercel | CI/CD and hosting optimized for Next.js |

## 3. Architectural Design

### 3.1. High-Level Overview

The application is built on the Next.js App Router, where frontend components and backend APIs (API Routes) coexist.
1.  **Frontend (Client):** Provides the user interface. Sends requests to the backend after wallet connection.
2.  **Backend (Next.js API Routes):** Acts as a secure proxy that receives requests from the frontend and relays them to external APIs (1inch, Gemini). API keys are securely managed as server-side environment variables.
3.  **External Services (External APIs):** 1inch Network and Gemini API.

### 3.2. LLM Integration Architecture (Function Calling)

This is the core of the project. The `/api/command` endpoint handles all natural language processing.
1.  User submits a command (e.g., "half of my ETH to USDC").
2.  The frontend POSTs the command string to `/api/command`.
3.  The backend sends the received command and predefined function schemas (e.g., `get_swap_quote`) to the Gemini API.
4.  The Gemini API interprets the user's intent and returns the function to call and its arguments in JSON format (e.g., `{ name: "get_swap_quote", arguments: { ... } }`).
5.  The backend invokes the corresponding 1inch API based on the returned function name.
6.  The result (e.g., a quote) is returned to the frontend to prompt the user for final confirmation.

### 3.3. Rendering Strategy

To achieve both fast initial loads and high interactivity, this application leverages the Next.js App Router's capabilities with the following strategy:

* **SSR + Streaming (Initial Load):**
    * On the initial application load, the static UI shell (header, footer, etc.) is server-side rendered (**SSR**) and sent to the client immediately for a fast FCP.
    * Dynamic components requiring data, like the `PortfolioDashboard`, are wrapped in `React.Suspense`. This allows the server to **stream** the HTML for these parts as soon as their data is ready, improving perceived load times.

* **CSR (Interaction):**
    * After the initial load, the application operates as a Client-Side Rendered (**CSR**) SPA.
    * All user interactions (wallet connection, command input, portfolio updates after a swap) and subsequent dynamic data fetching are handled on the client side.
    * Components using hooks like `useState`, `useEffect`, or those from `wagmi` are marked with the `"use client"` directive.

## 4. Directory Structure

A hybrid approach of Feature-Based and Type-Based organization is adopted to balance separation of concerns and development efficiency.
```
src/
├── app/
│   ├── api/
│   │   └── command/
│   │       └── route.ts       # Backend: API route for all LLM commands
│   ├── layout.tsx             # Root layout
│   └── page.tsx               # Main application page component
│
├── components/
│   └── ui/                    # UI components auto-generated by shadcn/ui
│
├── features/                  # ✨ Feature-based directories
│   │
│   ├── portfolio/             # Portfolio feature
│   │   ├── components/        #   - UI Components
│   │   │   ├── PortfolioDashboard.tsx
│   │   │   └── AssetTable.tsx
│   │   └── hooks/             #   - Logic Hooks
│   │       └── usePortfolio.ts
│   │
│   ├── command/               # Command feature
│   │   ├── components/
│   │   │   ├── CommandBar.tsx
│   │   │   └── ConfirmationDialog.tsx
│   │   └── hooks/
│   │       └── useCommandHandler.ts
│   │
│   └── wallet/                # Wallet connection feature
│       ├── components/
│       │   └── ConnectButton.tsx
│       └── providers/
│           └── Web3Provider.tsx   # wagmi configuration and Provider
│
├── lib/                         # Shared libraries and SDK wrappers
│   ├── 1inch/
│   │   └── sdk.ts             # Functions for calling 1inch APIs
│   ├── llm/
│   │   └── client.ts          # Client for calling the Gemini API
│   └── utils.ts               # Project-wide utility functions
│
├── store/
│   └── useAppStore.ts         # Global state management store with Zustand
│
└── styles/
└── globals.css            # Global CSS
```

## 5. Key Features & Implementation Plan

### 5.1. Portfolio Feature (`features/portfolio`)

* **`PortfolioDashboard.tsx`**: The main dashboard component. Displays data fetched from the `usePortfolio` hook. This component will be wrapped in `<Suspense>` to show a loading skeleton and be streamed from the server.
* **`usePortfolio.ts`**: A custom hook that gets the connected wallet address from `wagmi` and calls the `1inch Wallet Balances API` and `Token Prices API` via the backend to return formatted asset data.

### 5.2. Command Feature (`features/command`)

* **`CommandBar.tsx`**: The UI for user's natural language command input. Passes the input string to the `useCommandHandler`.
* **`useCommandHandler.ts`**: A custom hook that sends the command string to `/api/command`, manages the returned state (quote, error, etc.), and controls the visibility of the confirmation dialog.
* **`/api/command/route.ts`**:
    * Gets the command string from the request body.
    * Calls `lib/llm/client.ts` to request intent parsing from the Gemini API.
    * Executes the appropriate function from `lib/1inch/sdk.ts` based on the returned function call information.
    * Returns the result to the frontend.

### 5.3. Gemini Function Calling Definitions

The following functions will be defined and presented to Gemini within `/api/command/route.ts`.

| Function Name | Parameters | Description | Internal API |
| :--- | :--- | :--- | :--- |
| **`get_swap_quote`** | `from: string`, `to: string`, `amount: number` | Gets a quote for a swap. | 1inch Swap API |
| **`create_limit_order` (Stretch Goal)** | `from: string`, `to: string`, `amount: number`, `rate: number` | Creates a limit order. | 1inch Limit Order API |
| **`get_token_balance`** | `token: string` | Gets the balance for a specific token. | 1inch Wallet API |

## 6. Development Roadmap

1.  **Sprint 1: Foundation Setup**
    * Create Next.js project, setup shadcn/ui, wagmi.
    * Implement `Web3Provider` and `ConnectButton` to establish wallet connectivity.
2.  **Sprint 2: Portfolio Display**
    * Implement the 1inch API proxy and the `usePortfolio` hook.
    * Complete the `PortfolioDashboard` to display user assets.
3.  **Sprint 3: LLM Backend**
    * Implement the Gemini API integration (`lib/llm/client.ts`).
    * Verify that the `/api/command` route works with Function Calling and returns the intended JSON.
4.  **Sprint 4: E2E Swap Flow**
    * Integrate the LLM response with the 1inch SDK.
    * Complete the end-to-end flow from `CommandBar` -> `get_swap_quote` -> displaying the quote in `ConfirmationDialog`.
5.  **Sprint 5: Polish & Stretch Goals**
    * Refine UI/UX, enhance error handling.
    * **Stretch Goal:** Implement the `create_limit_order` flow.

